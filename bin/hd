#!/usr/bin/env python3
"""
Hex dump command line utility.

Author: Darren Mulholland <dmulholland@outlook.ie>
License: Public Domain

"""

__version__ = '1.1.0'


import argparse
import os
import signal
import sys


helptext = """\
Usage: %s [FLAGS] [OPTIONS] ARGUMENTS

Arguments:
  <file>     file to dump (default: stdin)

Options:
  -l <int>   bytes per line in output (default: 16)
  -n <int>   number of bytes to read
  -o <int>   byte offset at which to begin reading

Flags:
  --help     display this help text and exit
  --version  display version number and exit""" % os.path.basename(sys.argv[0])


class HelpAction(argparse.Action):

    """ Print our custom help text in place of the autogenerated default. """

    def __call__(self, parser, namespace, values, option_string=None):
        print(helptext)
        sys.exit()


# Suppress 'broken pipe' warnings when piping output through pagers.
# This resolves the issue when running under Cygwin on Windows.
if hasattr(signal, 'SIGPIPE'):
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)


def write(s):
    # Suppress 'broken pipe' warnings when piping output through pagers.
    # This resolves the issue when running natively on Windows.
    try:
        sys.stdout.write(s)
    except (IOError, OSError):
        sys.exit()


def writeln(offset, bytes, bpl):
    write('% 6X |' % offset)
    for i in range(bpl):
        write(' %02X' % bytes[i] if i < len(bytes) else '   ')
        if (i + 1) % 4 == 0 and i != bpl - 1:
            write(' ')
    write(' | ')
    for i in range(len(bytes)):
        write('%c' % bytes[i] if 32 <= bytes[i] <= 126 else '.')
    write('\n')


def dump(file, offset=0, bytes_to_read=-1, bpl=16):
    if offset:
        if file.seekable():
            file.seek(offset)
        else:
            sys.exit('Error: %s is not seekable.' % file.name)
    while True:
        if bytes_to_read > -1:
            bytes = file.read(bpl if bpl < bytes_to_read else bytes_to_read)
        else:
            bytes = file.read(bpl)
        if len(bytes):
            writeln(offset, bytes, bpl)
            offset += len(bytes)
            bytes_to_read -= len(bytes)
        else:
            break


def main():
    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument('file',
        nargs='?',
        help='file to dump (default: stdin)',
        type=argparse.FileType('rb'),
        default=sys.stdin.buffer,
    )
    parser.add_argument('--help',
        action = HelpAction,
        nargs=0,
        help = 'print this help message and exit',
    )
    parser.add_argument('--version',
        action='version',
        version=__version__,
    )
    parser.add_argument('-l',
        help='bytes per line in output (default: 16)',
        default=16,
        type=int,
        dest='bpl',
    )
    parser.add_argument('-n',
        nargs='?',
        help='number of bytes to read (default: 256)',
        type=int,
        default=-1,
        const=256,
        dest='num',
    )
    parser.add_argument('-o',
        help='offset at which to begin reading (default: 0)',
        type=int,
        default=0,
        dest='offset',
    )
    args = parser.parse_args()
    dump(args.file, args.offset, args.num, args.bpl)


if __name__ == '__main__':
    main()
